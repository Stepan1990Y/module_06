{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np # linear algebra\n",
    "import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)\n",
    "import sys\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.model_selection import KFold\n",
    "from tqdm.notebook import tqdm\n",
    "from catboost import CatBoostRegressor\n",
    "from sklearn.preprocessing import LabelEncoder\n",
    "import xgboost as xgb"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np # linear algebra\n",
    "import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)\n",
    "import sys\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.model_selection import KFold\n",
    "from tqdm.notebook import tqdm\n",
    "from sklearn.ensemble import StackingRegressor\n",
    "\n",
    "from sklearn.ensemble import RandomForestRegressor\n",
    "from sklearn.preprocessing import LabelEncoder\n",
    "from sklearn.linear_model import LinearRegression\n",
    "\n",
    "import time\n",
    "import os\n",
    "\n",
    "from pandas import Series\n",
    "import re\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from sklearn.base import clone\n",
    "from sklearn.neighbors import KNeighborsClassifier\n",
    "from sklearn.neighbors import KNeighborsRegressor\n",
    "from sklearn.model_selection import KFold\n",
    "from sklearn.feature_selection import f_classif, mutual_info_classif\n",
    "from sklearn.preprocessing import LabelEncoder, OneHotEncoder, StandardScaler\n",
    "from sklearn.ensemble import GradientBoostingRegressor\n",
    "from tqdm import tqdm\n",
    "from datetime import timedelta, datetime, date\n",
    "\n",
    "pd.pandas.set_option('display.max_columns', None)\n",
    "\n",
    "import json"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def mape(y_true, y_pred):\n",
    "    return np.mean( np.abs( (y_pred - y_true) / y_true ) )\n",
    "\n",
    "\n",
    "# Предобработка\n",
    "\n",
    "colors_list = {'0000CC': 'синий',\n",
    "               '4A2197': 'фиолетовый',\n",
    "               '040001': 'чёрный',\n",
    "               'EE1D19': 'красный',\n",
    "               '200204': 'коричневый',\n",
    "               'CACECB': 'серебристый',\n",
    "               '97948F': 'серый',\n",
    "               '22A0F8': 'голубой',\n",
    "               'FFD600': 'жёлтый',\n",
    "               'C49648': 'бежевый',\n",
    "               '007F00': 'зелёный',\n",
    "               '660099': 'пурпурный',\n",
    "               'DEA522': 'золотистый',\n",
    "               'FF8649': 'оранжевый',\n",
    "               'FFC0CB': 'розовый',\n",
    "               'FAFBFB': 'белый'}\n",
    "\n",
    "# Самые популярные: 1, менее популярные: 2,еще менее популярные: 3, не популярные: 4\n",
    "\n",
    "colors_range = {'синий': 1,\n",
    "                'фиолетовый': 3,\n",
    "                'чёрный': 1,\n",
    "                'красный': 2,\n",
    "                'коричневый': 2,\n",
    "                'серебристый': 1,\n",
    "                'серый': 1,\n",
    "                'голубой': 2,\n",
    "                'жёлтый': 3,\n",
    "                'бежевый': 2,\n",
    "                'зелёный': 2,\n",
    "                'пурпурный': 3,\n",
    "                'золотистый': 3,\n",
    "                'оранжевый': 3,\n",
    "                'розовый': 4,\n",
    "                'белый': 1}\n",
    "\n",
    "privod = {'передний': 1,\n",
    "          'задний': 3,\n",
    "          'полный': 2}\n",
    "\n",
    "\n",
    "# Функция для логарифмирования признаков:\n",
    "def log_func(df, column):\n",
    "    df[column] = df[column].apply( lambda x: np.log( x + 1 ) )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# всегда фиксируйте RANDOM_SEED, чтобы ваши эксперименты были воспроизводимы!\n",
    "RANDOM_SEED = 42"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "VERSION    = 16\n",
    "DIR_TRAIN  = '../input/parsing-all-moscow-auto-ru-09-09-2020/' # подключил к ноутбуку внешний датасет\n",
    "DIR_TEST   = '../input/sf-dst-car-price-prediction/'\n",
    "VAL_SIZE   = 0.20   # 20%"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "!ls '../input'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "train = pd.read_csv(DIR_TRAIN+'all_auto_ru_09_09_2020.csv') # датасет для обучения модели\n",
    "test = pd.read_csv(DIR_TEST+'test.csv')\n",
    "sample_submission = pd.read_csv(DIR_TEST+'sample_submission.csv')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "train.head(5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "test.head(5)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 1. EDA"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# перемеинуем model_name на model в тестовом датасете\n",
    "test.rename(columns={'model_name': 'model'}, inplace=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# проверим какие колонки отсутствуют в тестовой выборке\n",
    "\n",
    "print(set(test.columns)-set(train.columns))\n",
    "print(set(train.columns)-set(test.columns))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Удалим из тестовой выборки те признаки которые отсутствуют в трейне\n",
    "\n",
    "test = test.drop(['equipment_dict','image','vendor','car_url','model_info',\n",
    "                  'parsing_unixtime','priceCurrency','complectation_dict',\n",
    "                  'sell_id','super_gen'], axis=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# проверим колличетсво нулевых значений на тестовом датасете \n",
    "display(test.isnull().sum())\n",
    "\n",
    "# удалим признак Владение из за большого колличества пропусков\n",
    "test = test.drop('Владение', axis = 1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# теперь посмотрим более детально на тренировочный датасет\n",
    "\n",
    "display(train.isnull().sum())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# в первую очередь удалим те признаки которые отсутсвуют в тестовом датасете и признаки с большим колличеством пропусков:\n",
    "\n",
    "train = train.drop(['start_date','Комплектация','hidden','Состояние',\n",
    "                    'Владение','description'], axis=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# проверим еще раз на соотвествие колонок друг другу в обоих датасетах\n",
    "\n",
    "print(set(test.columns)-set(train.columns))\n",
    "print(set(train.columns)-set(test.columns))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# удалим из тестовой выборки 2 признака удаленных ранее из трейна\n",
    "\n",
    "test = test.drop(['Состояние','description'], axis=1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### bodyType"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(test.bodyType.unique())\n",
    "display(train.bodyType.unique()[0:20])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# как мы видим некоторые значения повторяются, есть смысл сократить тип кузова \n",
    "# только до первого слова в обоих датасетах:\n",
    "\n",
    "test['bodyType'] = test['bodyType'].astype(str).apply(lambda x: None if\n",
    "x.strip() == '' else x)\n",
    "test['bodyType'] = test['bodyType'].apply(lambda x: x.split(' ')[0].lower())\n",
    "train['bodyType'] = train['bodyType'].astype(str).apply(lambda x: None if\n",
    "x.strip() == '' else x)\n",
    "train['bodyType'] = train['bodyType'].apply(lambda x: x.split(' ')[0].lower())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sns.countplot(y=test['bodyType'], data=test,\n",
    "              order=test['bodyType'].value_counts().index)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sns.countplot(y=train['bodyType'], data=train,\n",
    "              order=train['bodyType'].value_counts().index)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# рассмотрим поближе NaN-ское значение в тренировочном датасете\n",
    "\n",
    "train[train['bodyType'] == 'nan']"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "отметим для себя что у этой Хонды слишком много пропусков в ключевых признаках - сэкономим время удалив данный экземпляр из выборки, вместо того чтобы на каждом этапе заполнять пропуски"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "train = train.loc[train['bodyType'] != 'nan']"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### brand\n",
    "поглядим на названия марок машин представленных в каждом датасете"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(test['brand'].unique())\n",
    "sns.countplot(y=test['brand'], data=test,\n",
    "              order=test['brand'].value_counts().index)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(train['brand'].unique())\n",
    "sns.countplot(y=train['brand'], data=train,\n",
    "              order=train['brand'].value_counts().index)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "названия марок авто соотвествуют друг другу, после объединения можно будет сделать Dummie переменные из этого признака\n",
    "\n",
    "Однако поскольку данный параметр завязан с признаком model - сократим выборку в тренировочном датасете до тех же самых моделей которые присутсвуют в тестовом"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "brand_list = test.brand.unique()\n",
    "\n",
    "train['brand'] = train['brand'].apply(lambda x: str.upper(x))\n",
    "train['bodyType'] = train['bodyType'].str.replace(' ', '')\n",
    "\n",
    "train = train[train['brand'].isin(brand_list)]\n",
    "train = train[train['price'] > 0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(len(train['model'].unique()))\n",
    "display(len(test['model'].unique()))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "видов моделей все еще слишком много для создания Dammie переменных, оставим 5 самых популярных и остальные модели перекодируем в other"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model_list = train['model'].append(test['model']).reset_index(drop=True)\n",
    "model_list.value_counts()[0:5]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def model(x):\n",
    "    if x == 'OCTAVIA':\n",
    "        x = 'OCTAVIA'\n",
    "    elif x == '5ER':\n",
    "        x = '5ER'\n",
    "    elif x == 'E_KLASSE':\n",
    "        x = 'E_KLASSE'\n",
    "    elif x == 'PASSAT':\n",
    "        x = 'PASSAT'\n",
    "    elif x == '3ER':\n",
    "        x = '3ER'\n",
    "    else:\n",
    "        x = 'OTHER'\n",
    "    return x"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "test['model'] = test['model'].map(model)\n",
    "train['model'] = train['model'].map(model)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### color"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(test['color'].unique())\n",
    "display(train['color'].unique())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "как мы видим в тренировочном датасете название цвета закодировано, воспользуемся словарем для замены"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "train['color'] = train['color'].replace(to_replace=colors_list)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(sns.countplot(y=train['color'], data=train,\n",
    "                      order=train['color'].value_counts().index))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "разделим все цвета на 4 группы - Самые популярные: 1, менее популярные: 2,еще менее популярные: 3, не популярные: 4"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "train['color'] = train['color'].replace(to_replace=colors_range)\n",
    "test['color'] = test['color'].replace(to_replace=colors_range)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### fuelType"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(test['fuelType'].unique())\n",
    "display(train['fuelType'].unique())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(test['fuelType'].value_counts())\n",
    "display(train['fuelType'].value_counts())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "поскольку типов топлива немного - можно создать Dummie переменные"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### numberOfDoors"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(train['numberOfDoors'].unique())\n",
    "display(train['numberOfDoors'].value_counts())\n",
    "display(sns.countplot(y=train['numberOfDoors'], data=train,\n",
    "                      order=train['numberOfDoors'].value_counts().index))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(test['numberOfDoors'].unique())\n",
    "display(test['numberOfDoors'].value_counts())\n",
    "display(sns.countplot(y=test['numberOfDoors'], data=test,\n",
    "                      order=test['numberOfDoors'].value_counts().index))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "отметим для себя что присутствует машина в обоих датасетах без дверей - посмотрим на нее более детально"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "train[train['numberOfDoors']==0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "test[test['numberOfDoors']==0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "поскольку марки и модели совпадают - оставим данную модель авто"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### enginePower"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(train['enginePower'].unique()[0:10])\n",
    "display(test['enginePower'].unique()[0:10])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Данный признак характеризует объем двигателя в л.c. - приведем тестовый часть датасета в подобающий вид"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "test['enginePower'] = test['enginePower'] .apply(lambda x: int(x[:-4]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Привод"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(train['Привод'].unique())\n",
    "display(sns.countplot(y=train['Привод'], data=train,\n",
    "                      order=train['Привод'].value_counts().index))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(test['Привод'].unique())\n",
    "display(sns.countplot(y=test['Привод'], data=test,\n",
    "                      order=test['Привод'].value_counts().index))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# снова прибегнем к замене категориональных признаков на числовые с помощью словаря \n",
    "\n",
    "train['Привод'] = train['Привод'].replace(to_replace=privod)\n",
    "test['Привод'] = test['Привод'].replace(to_replace=privod)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Руль"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(train['Руль'].unique())\n",
    "display(sns.countplot(y=train['Руль'], data=train,\n",
    "                      order=train['Руль'].value_counts().index))\n",
    "display(train['Руль'].isnull().sum())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(test['Руль'].unique())\n",
    "display(sns.countplot(y=test['Руль'], data=test,\n",
    "                      order=test['Руль'].value_counts().index))\n",
    "display(test['Руль'].isnull().sum())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Поменяем язык на латиницу в тестовом датасете\n",
    "\n",
    "test['Руль'] = test['Руль'].apply(\n",
    "    lambda x: 'LEFT' if x == 'Левый' else 'RIGHT')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Владельцы"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(test['Владельцы'].unique())\n",
    "display(sns.countplot(y=test['Владельцы'], data=test,\n",
    "                      order=test['Владельцы'].value_counts().index))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(train['Владельцы'].unique())\n",
    "display(sns.countplot(y=train['Владельцы'], data=train,\n",
    "                      order=train['Владельцы'].value_counts().index))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "test['Владельцы']=test['Владельцы'].apply(lambda x: int(x[0]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# В трейне наблюдаем много пропусков - слишком много чтобы удалять строки с NaN - заменим модой\n",
    "\n",
    "train['Владельцы'] = train['Владельцы'].fillna(train['Владельцы'].mode()[0])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### ПТС"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(test['ПТС'].unique())\n",
    "display(sns.countplot(y=test['ПТС'], data=test,\n",
    "                      order=test['ПТС'].value_counts().index))\n",
    "display(test['ПТС'].value_counts())\n",
    "display(test['ПТС'].isnull().sum())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(train['ПТС'].unique())\n",
    "display(sns.countplot(y=train['ПТС'], data=train,\n",
    "                      order=train['ПТС'].value_counts().index))\n",
    "display(train['ПТС'].value_counts())\n",
    "display(train['ПТС'].isnull().sum())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# есть пропуски - заменяем на моду и перекодируем признаки в числовые\n",
    "\n",
    "train['ПТС'] = train['ПТС'].fillna(train['ПТС'].mode()[0])\n",
    "test['ПТС'] = test['ПТС'].fillna(test['ПТС'].mode()[0])\n",
    "train['ПТС'] = train['ПТС'].apply(lambda x: 1 if x == 'ORIGINAL' else 0)\n",
    "test['ПТС'] = test['ПТС'].apply(lambda x: 1 if x == 'Оригинал' else 0)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Таможня"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(test['Таможня'].value_counts())\n",
    "display(test['Таможня'].isnull().sum())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(train['Таможня'].value_counts())\n",
    "display(train['Таможня'].isnull().sum())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# все авто были растаможены - удаляем данный признак из обоих датасетов\n",
    "\n",
    "train = train.drop(['Таможня'], axis=1)\n",
    "test = test.drop(['Таможня'], axis=1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### vehicleConfiguration\n",
    "данный признак содержит информацию о типе кузова, коробке передач и объеме двигателя; первые два признака уже представлены в наших датасетах, а вот объем двигателя является одним из основопологающих факторов ценообразования"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# посмотрим на данный признак поближе\n",
    "\n",
    "display(train['vehicleConfiguration'].unique()[0:10])\n",
    "display(test['vehicleConfiguration'].unique()[0:10])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# попытаемся вытащить нужную нам информацию из тестового датасета\n",
    "\n",
    "test['vehicleConfiguration'] = test['vehicleConfiguration'].astype(str)\n",
    "test['vehicleConfiguration'] = test['vehicleConfiguration'].str.extract(\n",
    "    '(\\d.\\d)', expand=False).str.strip()\n",
    "test['vehicleConfiguration'] = test['vehicleConfiguration'].astype(float)\n",
    "display(test['vehicleConfiguration'].isnull().sum())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# проделаем туже самую операцию и на тренировочном\n",
    "\n",
    "train['vehicleConfiguration'] = train['vehicleConfiguration'].astype(str)\n",
    "train['vehicleConfiguration'] = train['vehicleConfiguration'].str.extract(\n",
    "    '(\\d.\\d)', expand=False).str.strip()\n",
    "train['vehicleConfiguration'] = train['vehicleConfiguration'].astype(float)\n",
    "train['vehicleConfiguration'] = train['vehicleConfiguration'].apply(\n",
    "    lambda x: round(x / 100, 1) if (x > 10)\n",
    "    else round(x, 1))\n",
    "display(train['vehicleConfiguration'].isnull().sum())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "mean_test = round(test['vehicleConfiguration'].mean(), 1)\n",
    "mean_train = round(train['vehicleConfiguration'].mean(), 1)\n",
    "test['vehicleConfiguration'].fillna(mean_test, inplace=True)\n",
    "train['vehicleConfiguration'].fillna(mean_train, inplace=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(test['vehicleConfiguration'].describe())\n",
    "display(train['vehicleConfiguration'].describe())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### engineDisplacement and name¶\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(train['engineDisplacement'].unique()[-20:-5])\n",
    "display(test['engineDisplacement'].unique()[:10])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(train['name'].unique()[-20:-5])\n",
    "display(test['name'].unique()[:10])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Поскольку эти два признака во многом повторяют уже имеющуюся у нас информацию о типе двигателя - удалим их из датасетов\n",
    "\n",
    "train = train.drop(['engineDisplacement', 'name'], axis=1)\n",
    "test = test.drop(['engineDisplacement', 'name'], axis=1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### vehicleTransmission\n",
    "Данный признак характеризует коробку передач, посмотрим что внутри и если надо приведем к одинаковому виду"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(train['vehicleTransmission'].unique())\n",
    "display(sns.countplot(y=train['vehicleTransmission'], data=train,\n",
    "                      order=train['vehicleTransmission'].value_counts().index))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "display(test['vehicleTransmission'].unique())\n",
    "display(sns.countplot(y=test['vehicleTransmission'], data=test,\n",
    "                      order=test['vehicleTransmission'].value_counts().index))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# напишем быструю функцию для замены коробки передач на нужное нам значение\n",
    "\n",
    "def transmission(x):\n",
    "    if x == 'механическая':\n",
    "        x = 'MECHANICAL'\n",
    "    elif x == 'автоматическая':\n",
    "        x = 'AUTOMATIC'\n",
    "    elif x == 'роботизированная':\n",
    "        x = 'ROBOT'\n",
    "    else:\n",
    "        x = 'VARIATOR'\n",
    "    return x\n",
    "\n",
    "\n",
    "test['vehicleTransmission'] = test['vehicleTransmission'].map(transmission)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Price"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# удалим из тренировочного датасета те модели на которые цена не указана\n",
    "\n",
    "train=train[train['price']>0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### modelDate, productionDate, mileage"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "num_cols = ['modelDate', 'productionDate', 'mileage']\n",
    "\n",
    "for i in num_cols:\n",
    "    plt.figure()\n",
    "    sns.distplot(test[i][test[i] > 0].dropna(), kde=False, rug=False)\n",
    "    plt.title(i)\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i in num_cols:\n",
    "    plt.figure()\n",
    "    sns.distplot(train[i][train[i] > 0].dropna(), kde=False, rug=False)\n",
    "    plt.title(i)\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Отметим для себя что распределение у признаков в обоих датасетах одинаковое - что в общем то логично Пролагорифмируем эти 3 признака"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "log_func(test, num_cols)\n",
    "log_func(train, num_cols)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Корреляционный анализ"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sns.set(font_scale=1)\n",
    "plt.subplots(figsize=(12, 10))\n",
    "sns.heatmap(train.corr(), annot=True, fmt='.2f', linewidths=0.1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "как мы видим цена автомобиля растет в зависимости от даты производства и мощности двигателя, в тоже время падает при увеличении пробега и что очень удивительно от цвета модели"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "corr = train.corr()\n",
    "corr[corr == 1] = 0\n",
    "c1 = corr.abs().unstack()\n",
    "c1.sort_values(ascending = False)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "ModelDate и ProductionDate сильно скорелированы между собой - имеет смысл создать один общий новый признак"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 2. Data Preprocessing"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# построим baseline\n",
    "columns = ['bodyType', 'brand', 'enginePower', 'fuelType', 'mileage', 'model',\n",
    "           'numberOfDoors', 'productionDate', 'vehicleConfiguration',\n",
    "           'vehicleTransmission', 'Владельцы', 'ПТС', 'Привод', 'Руль',\n",
    "           'color', 'modelDate']\n",
    "df_train = train[columns]\n",
    "df_test = test[columns]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "y = train['price']"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Label Encoding"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# ВАЖНО! дря корректной обработки признаков объединяем трейн и тест в один датасет\n",
    "df_train['sample'] = 1  # помечаем где у нас трейн\n",
    "df_test['sample'] = 0  # помечаем где у нас тест\n",
    "\n",
    "data = df_test.append(df_train, sort=False).reset_index(\n",
    "    drop=True)  # объединяем\n",
    "data.info()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Добавляем в объединенные данные dummie-переменные\n",
    "dummie_columns = ['bodyType', 'brand', 'fuelType', 'Руль', 'model',\n",
    "                  'vehicleTransmission']\n",
    "for item in dummie_columns:\n",
    "    dummie_df = pd.get_dummies(data[item].apply(pd.Series).stack()).sum(\n",
    "        level=0)  # Создаём сет dummie-переменных\n",
    "    data = pd.concat([data, dummie_df], axis=1)\n",
    "data = data.drop(dummie_columns, axis=1)\n",
    "data.columns"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# создадим новую переменную возраст модели\n",
    "data['model_age'] = (2020-data['productionDate'])\n",
    "# пролагорифмируем данный признак\n",
    "log_func(data, 'model_age')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "data.head(4)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# применим нормализацию к численным признакам\n",
    "from sklearn.preprocessing import MinMaxScaler\n",
    "\n",
    "scaler = MinMaxScaler()\n",
    "columns_to_scale = ['enginePower', 'mileage', 'numberOfDoors',\n",
    "                    'productionDate', 'vehicleConfiguration',\n",
    "                    'model_age']\n",
    "scaler.fit(data[columns_to_scale])\n",
    "data[columns_to_scale] = scaler.transform(data[columns_to_scale])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Разделяем датасеты\n",
    "X = data.query('sample == 1').drop(['sample'], axis=1)\n",
    "X_sub = data.query('sample == 0').drop(['sample'], axis=1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Train Split"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "X_train, X_test, y_train, y_test = train_test_split( X, y, test_size=VAL_SIZE,\n",
    "                                                     shuffle=True,\n",
    "                                                     random_state=RANDOM_SEED )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "tmp_train = X_train.copy()\n",
    "tmp_train['price'] = y_train"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Model 1 LinearRegression\n",
    "рассмотрим первую модель - будем считать ее наивной - Линеарной Регрессии"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "lin_reg = LinearRegression().fit(X_train, y_train)\n",
    "y_pred = lin_reg.predict(X_test)\n",
    "print(f\"Точность наивной модели по метрике MAPE: {(mape(y_test, y_pred))*100:0.2f}%\")\n",
    "\n",
    "# Точность составила 90% - что ж, есть от чего плясать"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Model 2 GradientBoosting"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.ensemble import GradientBoostingRegressor\n",
    "reg = GradientBoostingRegressor(random_state=0)\n",
    "reg.fit(X_train, y_train)\n",
    "predict = reg.predict(X_test)\n",
    "\n",
    "print(f\"Точность модели GradientBoosting по метрике MAPE: {(mape(y_test, predict))*100:0.2f}%\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# попробуем пролагорифмировать целевую переменную\n",
    "\n",
    "reg.fit( X_train, np.log( y_train ) )\n",
    "y_pred = reg.predict( X_test )\n",
    "\n",
    "print(f\"Точность модели GradientBoosting Log по метрике MAPE: {(mape( y_test, predict )) * 100:0.2f}%\" )\n",
    "\n",
    "# точность модели улучшилась до 24%, процедура логорифмирования не улучшила показатели"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Model 3 Random Forest"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rf = RandomForestRegressor(n_estimators=1000,\n",
    "                            n_jobs=-1,\n",
    "                            max_depth=50,\n",
    "                            max_features='log2',\n",
    "                            random_state=RANDOM_SEED,\n",
    "                            oob_score=True)\n",
    "rf.fit(X_train,y_train)\n",
    "\n",
    "y_pred = rf.predict(X_test)\n",
    "print(f\"Точность модели RF по метрике MAPE лого: {(mape(y_test, y_pred))*100:0.2f}%\")\n",
    "\n",
    "# Модель Случайного Леса с вручную подобранными гиперпараметрами - показала 14% - уже достойный результат"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Model 4 Cat Boost"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "X_train, X_test, y_train, y_test = train_test_split( X, y, test_size=VAL_SIZE,\n",
    "                                                     shuffle=True,\n",
    "                                                     random_state=RANDOM_SEED )\n",
    "model = CatBoostRegressor( iterations=10000,\n",
    "                           random_seed=RANDOM_SEED,\n",
    "                           eval_metric='MAPE',\n",
    "                           custom_metric=['R2', 'MAE'],\n",
    "                           silent=True,\n",
    "                           )\n",
    "model.fit( X_train, y_train,\n",
    "           # cat_features=cat_features_ids,\n",
    "           eval_set=(X_test, y_test),\n",
    "           verbose_eval=0,\n",
    "           use_best_model=True,\n",
    "           # plot=True\n",
    "           )\n",
    "\n",
    "model.save_model( 'catboost_single_model_baseline.model' )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# оцениваем точность\n",
    "predict = (model.predict(X_test))\n",
    "\n",
    "print(f\"Точность модели CatBoost по метрике MAPE: {(mape(y_test, predict))*100:0.2f}%\")\n",
    "\n",
    "# Cat Boost показал результат получше - 13.85%"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Model 5: Xgboosting"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xb = xgb.XGBRegressor( objective='reg:squarederror', colsample_bytree=0.5,\n",
    "                       learning_rate=0.03, \\\n",
    "                       max_depth=12, alpha=1, n_jobs=-1, n_estimators=1000 )\n",
    "xb.fit( X_train, np.log( y_train + 1 ) )\n",
    "\n",
    "pred_xb = (xb.predict( X_test ))\n",
    "pred_xb_sub = np.exp( xb.predict( X_sub ) )\n",
    "\n",
    "# max_depth 12 = 12.04%\n",
    "# max_depth 14 = 12.05%\n",
    "\n",
    "print(f\"Точность модели по метрике MAPE: {(mape(y_test, np.exp(pred_xb)))*100:0.2f}%\")\n",
    "\n",
    "# модель XG Boosting - показала наилучший результат - его и засабмитим"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Submission"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sample_submission['price'] = pred_xb_sub\n",
    "sample_submission.to_csv(f'submission.csv', index=False)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
